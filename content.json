{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"rpc1","slug":"rpc1","date":"2025-05-21T05:56:20.000Z","updated":"2025-05-21T07:34:02.696Z","comments":true,"path":"2025/05/21/rpc1/","permalink":"http://example.com/2025/05/21/rpc1/","excerpt":"","text":"前言&emsp;&emsp;我的RPC项目来自于复现Gitee上的一个开源项目，不过在复现的时候根据自己对RPC的理解，增加了部分代码，比如服务注册和序列化的优化。这一系列的博客主要的目的就是记录一下自己增加这些代码的初心和实现是遇到的一些难题。 自动服务注册我对RPC的理解&emsp;&emsp;这里贴一段非常官方的说法：RPC（Remote Procedure Call，远程过程调用）是一种通过网络进行进程间通信的协议。RPC协议允许一个进程调用另一个进程的某个方法，就像调用本地方法一样。根据这段描述，我认为RPC的一个重要的目标就是调用远程方法就和调用一个本地库一样，毫无感知。 我认为的RPC的组成&emsp;&emsp;基于我粗略的学习Spring Cloud的认知，我觉得一个RPC的服务主要分为三个部分。一个是服务接口的提供方，这个部分的开发应该是最早的，其提供了RPC过程中需要调用的实体类以及函数接口，并且被打包成jar包安装到另外两个部分中。第二个部分是服务的实现方，这个部分实现提供方的接口，以供调用方通过web调用。最后就是调用方。调用方调用jar包中的接口，以此调用实现方中的最终实现。 服务注册&emsp;&emsp;第一个问题就是我们为什么需要服务注册。事实上RPC在调用的时候需要通过反射机制解析接口的内容，比如提供接口的接口类、方法名以及参数类型和返回值类型。然后使用合适的web框架将请求发送到服务实现方。服务实现方根据接口类、方法名以及参数类型和返回值类型找到对应的实现，然后调用实现，最后返回调用结果和函数的结果。这里存在一个问题，调用方只知道接口类、方法名以及参数类型和返回值类型，但是不知道对应的实现。因此服务的提供方就必须要将实现方注册到服务注册中心，服务调用方才能找到对应的实现方。在我学习的开源项目中，这个部分是由提供方手动注册实现的： 123456789101112131415161718192021222324public class ServiceProvider &#123; /** * 一个实现类可能实现多个接口 */ private Map&lt;String, Object&gt; interfaceProvider; public ServiceProvider()&#123; this.interfaceProvider = new HashMap&lt;&gt;(); &#125; public void provideServiceInterface(Object service)&#123; String serviceName = service.getClass().getName(); Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces(); for(Class clazz : interfaces)&#123; interfaceProvider.put(clazz.getName(),service); &#125; &#125; public Object getService(String interfaceName)&#123; return interfaceProvider.get(interfaceName); &#125;&#125; 12345678910111213141516public class TestServer &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); BlogService blogService = new BlogServiceImpl();// Map&lt;String, Object&gt; serviceProvide = new HashMap&lt;&gt;();// serviceProvide.put(&quot;com.ganghuan.myRPCVersion2.service.UserService&quot;,userService);// serviceProvide.put(&quot;com.ganghuan.myRPCVersion2.service.BlogService&quot;,blogService); ServiceProvider serviceProvider = new ServiceProvider(); serviceProvider.provideServiceInterface(userService); serviceProvider.provideServiceInterface(blogService); RPCServer RPCServer = new SimpleRPCRPCServer(serviceProvider); RPCServer.start(8899); &#125;&#125; &emsp;&emsp;这个实现方法看上去没什么问题，但是经过Spring框架熏陶过的我们肯定觉得这个方法不优雅。首先在服务启动的时候我们要手动的创建实现类，那么后续如果服务终止对资源的释放还得手动实现，这太过麻烦。因此将实现类注册为bean才是一个优雅的选择。通过注册bean然后在启动时找到bean手动放入serviceProvider中还是不够优雅，因此我们就需要利用到bean的生命周期，在服务创建完成时就将bean注册进serviceProvider中。因此我自定义了一个CustomService注解用于修饰我需要注册的实现类。 1234567@Target(ElementType.TYPE) // 只能用在类上@Retention(RetentionPolicy.RUNTIME) // 运行时可用@Service // 继承 @Service 的功能public @interface CustomService &#123; // 可添加额外的属性 String value() default &quot;&quot;;&#125; &emsp;&emsp;然后在bean的生命周期中解析这个注解，对所有包含了这个注解的bean进行注册进serviceProvider中。 1234567891011121314@Componentpublic class CustomServicePostProcessor implements BeanPostProcessor &#123; // 用于存放所有 @CustomService 修饰的 Bean @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // 判断 Bean 是否被 @CustomService 修饰 if (bean.getClass().isAnnotationPresent(CustomService.class)) &#123; ServiceProvider.provideServiceInterface(bean); &#125; return bean; &#125;&#125; &emsp;&emsp;最后我们在Spring中配置这个生命周期的处理，这样我们就完成了自动服务注册。","categories":[],"tags":[]}],"categories":[],"tags":[]}
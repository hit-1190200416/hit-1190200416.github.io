{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://hit-1190200416.github.io","root":"/"},"pages":[],"posts":[{"title":"rpc2","slug":"rpc2","date":"2025-05-21T08:19:51.000Z","updated":"2025-05-21T08:55:29.516Z","comments":true,"path":"2025/05/21/rpc2/","permalink":"http://hit-1190200416.github.io/2025/05/21/rpc2/","excerpt":"","text":"序列化的作用&emsp;&emsp;这里先粘贴一段经典的序列化的定义：序列化是RPC中一个重要的功能，它的作用是把一个对象序列化成字节数组，然后通过网络传输到另一个进程，再反序列化成对象。在我们的RPC框架中，我们将需要调用的接口的具体信息以及调用的参数封装到一个对象中，然后将这个对象序列后化传输到服务的提供方。同样的，提供方也要将接口返回的结果序列化后再传回给调用方。 序列化的方式&emsp;&emsp;在我参考的开源项目中实现了java原生的序列化和基于json的序列化两种方式。但是在我查到的资料中，有很多要优于这两种序列化的实现。最早我想自己实现一下性能最强的protobuf进行序列化。不过这种序列化方式还需要单独用中间语言定义实体并编译，感觉并不符合RPC框架的初衷遂放弃。随后我盯上了更为简单的protostuff序列化。为了证明这个序列化的有效性，我编写了一个简单的测试类，分析不同序列化框架下对象序列化后的大小。传输的过程中我们需要将对象向上造型为Object类型，并记录其class信息，以方便后续的调用。在这里我用一个简单的Student类型和Exam类型来模拟这个过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Getter@Setter@AllArgsConstructor@NoArgsConstructor@Data@SerializationRegisterclass Student implements Serializable &#123; @Tag(1) private String name; @Tag(2) private int age; @Tag(3) private Object data; @Tag(4) private Class clazz;&#125;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@SerializationRegisterclass Exam implements Serializable &#123; @Override public String toString() &#123; return &quot;Exam&#123;&quot; + &quot;score=&quot; + score + &quot;, course=&#x27;&quot; + course + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Tag(1) private int score; @Tag(2) private String course;&#125;public class main &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Exam exam = new Exam(99, &quot;zz&quot;); Object o = exam; Student student = new Student(&quot;xx&quot;, 20, o, Exam.class); JsonSerializer jsonSerializer = new JsonSerializer(); System.out.println(&quot;json序列化长度:&quot; + jsonSerializer.serialize(student).length); System.out.println(&quot;ProtoStuff序列化长度:&quot; + ProtoStuffUtil.serialize(student).length); &#125;&#125; &emsp;&emsp;然后我们测试两种序列化框架的序列化结果:&emsp;&emsp;从结果中可以发现，ProtoStuff序列化在长度上确实优于Json。但是这还不够，我们接下来要知道这个序列化的瓶颈在哪儿。很明显，与正常的序列化相比，我们在这里序列化最大的开销就是为了能够还原Object类型时所记录的Class信息。因此我们可以很自然的想到我们的调用方和提供方都有同样的类信息，那么我们能不能用类名来替代Class对象呢？答案是可以的，我们先修改Student类，让Object对象变成一个字节数组，然后将Class对象变为字符串，在序列化和反序列化的双方通过字符串去查找类即可。 1","categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://hit-1190200416.github.io/tags/rpc/"},{"name":"序列化","slug":"序列化","permalink":"http://hit-1190200416.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"rpc1","slug":"rpc1","date":"2025-05-21T05:56:20.000Z","updated":"2025-05-21T08:46:57.886Z","comments":true,"path":"2025/05/21/rpc1/","permalink":"http://hit-1190200416.github.io/2025/05/21/rpc1/","excerpt":"","text":"前言&emsp;&emsp;我的RPC项目来自于复现Gitee上的一个开源项目，不过在复现的时候根据自己对RPC的理解，增加了部分代码，比如服务注册和序列化的优化。这一系列的博客主要的目的就是记录一下自己增加这些代码的初心和实现是遇到的一些难题。 自动服务注册我对RPC的理解&emsp;&emsp;这里贴一段非常官方的说法：RPC（Remote Procedure Call，远程过程调用）是一种通过网络进行进程间通信的协议。RPC协议允许一个进程调用另一个进程的某个方法，就像调用本地方法一样。根据这段描述，我认为RPC的一个重要的目标就是调用远程方法就和调用一个本地库一样，毫无感知。 我认为的RPC的组成&emsp;&emsp;基于我粗略的学习Spring Cloud的认知，我觉得一个RPC的服务主要分为三个部分。一个是服务接口的提供方，这个部分的开发应该是最早的，其提供了RPC过程中需要调用的实体类以及函数接口，并且被打包成jar包安装到另外两个部分中。第二个部分是服务的实现方，这个部分实现提供方的接口，以供调用方通过web调用。最后就是调用方。调用方调用jar包中的接口，以此调用实现方中的最终实现。 服务注册&emsp;&emsp;第一个问题就是我们为什么需要服务注册。事实上RPC在调用的时候需要通过反射机制解析接口的内容，比如提供接口的接口类、方法名以及参数类型和返回值类型。然后使用合适的web框架将请求发送到服务实现方。服务实现方根据接口类、方法名以及参数类型和返回值类型找到对应的实现，然后调用实现，最后返回调用结果和函数的结果。这里存在一个问题，调用方只知道接口类、方法名以及参数类型和返回值类型，但是不知道对应的实现。因此服务的提供方就必须要将实现方注册到服务注册中心，服务调用方才能找到对应的实现方。在我学习的开源项目中，这个部分是由提供方手动注册实现的： 123456789101112131415161718192021222324public class ServiceProvider &#123; /** * 一个实现类可能实现多个接口 */ private Map&lt;String, Object&gt; interfaceProvider; public ServiceProvider()&#123; this.interfaceProvider = new HashMap&lt;&gt;(); &#125; public void provideServiceInterface(Object service)&#123; String serviceName = service.getClass().getName(); Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces(); for(Class clazz : interfaces)&#123; interfaceProvider.put(clazz.getName(),service); &#125; &#125; public Object getService(String interfaceName)&#123; return interfaceProvider.get(interfaceName); &#125;&#125; 12345678910111213141516public class TestServer &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); BlogService blogService = new BlogServiceImpl();// Map&lt;String, Object&gt; serviceProvide = new HashMap&lt;&gt;();// serviceProvide.put(&quot;com.ganghuan.myRPCVersion2.service.UserService&quot;,userService);// serviceProvide.put(&quot;com.ganghuan.myRPCVersion2.service.BlogService&quot;,blogService); ServiceProvider serviceProvider = new ServiceProvider(); serviceProvider.provideServiceInterface(userService); serviceProvider.provideServiceInterface(blogService); RPCServer RPCServer = new SimpleRPCRPCServer(serviceProvider); RPCServer.start(8899); &#125;&#125; &emsp;&emsp;这个实现方法看上去没什么问题，但是经过Spring框架熏陶过的我们肯定觉得这个方法不优雅。首先在服务启动的时候我们要手动的创建实现类，那么后续如果服务终止对资源的释放还得手动实现，这太过麻烦。因此将实现类注册为bean才是一个优雅的选择。通过注册bean然后在启动时找到bean手动放入serviceProvider中还是不够优雅，因此我们就需要利用到bean的生命周期，在服务创建完成时就将bean注册进serviceProvider中。因此我自定义了一个CustomService注解用于修饰我需要注册的实现类。 1234567@Target(ElementType.TYPE) // 只能用在类上@Retention(RetentionPolicy.RUNTIME) // 运行时可用@Service // 继承 @Service 的功能public @interface CustomService &#123; // 可添加额外的属性 String value() default &quot;&quot;;&#125; &emsp;&emsp;然后在bean的生命周期中解析这个注解，对所有包含了这个注解的bean进行注册进serviceProvider中。 1234567891011121314@Componentpublic class CustomServicePostProcessor implements BeanPostProcessor &#123; // 用于存放所有 @CustomService 修饰的 Bean @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // 判断 Bean 是否被 @CustomService 修饰 if (bean.getClass().isAnnotationPresent(CustomService.class)) &#123; ServiceProvider.provideServiceInterface(bean); &#125; return bean; &#125;&#125; &emsp;&emsp;最后我们在Spring中配置这个生命周期的处理，这样我们就完成了自动服务注册。","categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://hit-1190200416.github.io/tags/rpc/"},{"name":"bean的生命周期","slug":"bean的生命周期","permalink":"http://hit-1190200416.github.io/tags/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]}],"categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://hit-1190200416.github.io/tags/rpc/"},{"name":"序列化","slug":"序列化","permalink":"http://hit-1190200416.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"bean的生命周期","slug":"bean的生命周期","permalink":"http://hit-1190200416.github.io/tags/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]}
{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://hit-1190200416.github.io","root":"/"},"pages":[],"posts":[{"title":"rag","slug":"rag","date":"2025-08-07T07:31:27.000Z","updated":"2025-08-07T08:04:28.765Z","comments":true,"path":"2025/08/07/rag/","permalink":"http://hit-1190200416.github.io/2025/08/07/rag/","excerpt":"","text":"前言&emsp;&emsp;我在烂柿子平台看连载小说的时候，有时候会遇到因为放了一段时间没看导致前面的一些伏笔或者联动的部分完全忘了，这个时候势必会影响阅读的体验。我希望这些小说平台能出一个就小说内容对AI提问的功能来解决这个问题，比如某某道具的作用是什么、某某角色做过什么事。不过很可惜，目前的小说平台并没有类似的功能。想到我之前学习过一个小说商城的项目，所以我想自己尝试实现一下这个功能。&emsp;&emsp;想到目前大模型落地相关的工作特别火，因此我想使用RAG的方式来实现这个功能，我希望能够满足以下几个我的需求： 因为小说中有的概念在防止一段时间后可能会完全忘记，所以希望有一个功能能够提示我这个概念的含义。 有时候小说可能会跳着读，所以我希望能有个功能能够概括我跳过的中间几个章节的内容。 最后有时候追连载追着追着就忘记前面几章的内容，因此我希望能有一个简单的前情提要功能。 简单实现&emsp;&emsp;前期准备：大模型选择使用deepseek API，价格不贵效果也不错。RAG框架使用langchain，简单易上手。&emsp;&emsp;为了实现这个功能，第一步就是要准备数据，我在网络上找到了《诡舍》这本小说的txt文件，后续就以这本小说为提问模板。找到txt文件后就需要格式化数据。原始数据如图所示。这样的数据太大，即不好分块，也不好完成后续的根据章节进行提问，因此首先我需要根据章节将小说进行拆分。 &emsp;&emsp;接下来就是数据的加载，毕竟我们在这里进行分析的是小说，所以在分块器这里我们选用语意分块器，这种分块器仅仅在语意有剧烈转折时会对文本进行切分，比较适合我们的小说分析。语意分块模块中每次加载小说的一个章节，使用语义信息对其进行分块处理。考虑到后续我们还需要根据章节进行检索提问，因此我们在元数据这里加上了章节名。 1234567891011121314151617class SemanticChunkerMoudule: def __init__(self, embeddings): # 初始化 SemanticChunker self.text_splitter = SemanticChunker( embeddings, breakpoint_threshold_type=&quot;percentile&quot;, # 也可以是 &quot;standard_deviation&quot;, &quot;interquartile&quot;, &quot;gradient&quot; breakpoint_threshold_amount=0.5, ) def chunk_text(self, txt_path): loader = TextLoader(txt_path, encoding=&quot;utf-8&quot;) documents = loader.load() docs = self.text_splitter.split_documents(documents) docs = [Document(page_content=doc.page_content, metadata=&#123;&quot;chapter_name&quot;: Path(txt_path).stem&#125;) for doc in docs] return docs &emsp;&emsp;有了分块数据后我们就要考虑对embeddings的存储了，在这里因为我们仅仅涉及到文本这个单模态数据，因此在这里我选择FAISS作为embeddings的存储方式。 1234567891011121314def faiss_construct(self): local_faiss_path = self.data_path + &quot;_faiss&quot; if os.path.exists(local_faiss_path): vectorstore = FAISS.load_local( local_faiss_path, self.embeddings, allow_dangerous_deserialization=True ) else: self.load_data() os.makedirs(local_faiss_path, exist_ok=True) vectorstore = FAISS.from_documents(self.docs, self.embeddings) vectorstore.save_local(local_faiss_path) return vectorstore &emsp;&emsp;最后我们通过将问题编码后检索数据库中最匹配的内容将其作为上下文对大模型进行提问即可。 1234567891011121314151617181920212223242526272829303132if __name__ == &quot;__main__&quot;: vectorstore = DataPreparationModule(data_path=&quot;guishe&quot;).faiss_construct() # 提示词模板 prompt = ChatPromptTemplate.from_template(&quot;&quot;&quot;请根据下面提供的上下文信息来回答问题。 请确保你的回答完全基于这些上下文。 如果上下文中没有足够的信息来回答问题，请直接告知：“抱歉，我无法根据提供的上下文找到相关信息来回答此问题。” 上下文: &#123;context&#125; 问题: &#123;question&#125; 回答:&quot;&quot;&quot; ) # 配置大语言模型 llm = ChatDeepSeek( model=&quot;deepseek-chat&quot;, temperature=0.7, max_tokens=2048, api_key=os.getenv(&quot;DEEPSEEK_API_KEY&quot;) ) # 用户查询 question = &quot;什么是鬼器？&quot; # 在向量存储中查询相关文档 retrieved_docs = vectorstore.similarity_search(question, k=3) docs_content = &quot;\\n\\n&quot;.join(doc.page_content for doc in retrieved_docs) answer = llm.invoke(prompt.format(question=question, context=docs_content)) print(answer.content) &emsp;&emsp;运行结果如下：&emsp;&emsp;可以看到，这个简单的实现已经基本能够满足我们第一个需求，可见大模型的实力之强悍。","categories":[],"tags":[]},{"title":"rpc2","slug":"rpc2","date":"2025-05-21T08:19:51.000Z","updated":"2025-05-21T11:28:27.390Z","comments":true,"path":"2025/05/21/rpc2/","permalink":"http://hit-1190200416.github.io/2025/05/21/rpc2/","excerpt":"","text":"序列化的作用&emsp;&emsp;这里先粘贴一段经典的序列化的定义：序列化是RPC中一个重要的功能，它的作用是把一个对象序列化成字节数组，然后通过网络传输到另一个进程，再反序列化成对象。在我们的RPC框架中，我们将需要调用的接口的具体信息以及调用的参数封装到一个对象中，然后将这个对象序列后化传输到服务的实现方。同样的，实现方也要将接口返回的结果序列化后再传回给调用方。 序列化的方式&emsp;&emsp;在我参考的开源项目中实现了java原生的序列化和基于json的序列化两种方式。但是在我查到的资料中，有很多要优于这两种序列化的实现。最早我想自己实现一下性能最强的protobuf进行序列化。不过这种序列化方式还需要单独用中间语言定义实体并编译，感觉并不符合RPC框架的初衷遂放弃。随后我盯上了更为简单的protostuff序列化。为了证明这个序列化的有效性，我编写了一个简单的测试类，分析不同序列化框架下对象序列化后的大小。传输的过程中我们需要将对象向上造型为Object类型，并记录其class信息，以方便后续的调用。在这里我用一个简单的Student类型和Exam类型来模拟这个过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Getter@Setter@AllArgsConstructor@NoArgsConstructor@Data@SerializationRegisterclass Student implements Serializable &#123; @Tag(1) private String name; @Tag(2) private int age; @Tag(3) private Object data; @Tag(4) private Class clazz;&#125;@Getter@Setter@AllArgsConstructor@NoArgsConstructor@SerializationRegisterclass Exam implements Serializable &#123; @Override public String toString() &#123; return &quot;Exam&#123;&quot; + &quot;score=&quot; + score + &quot;, course=&#x27;&quot; + course + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125; @Tag(1) private int score; @Tag(2) private String course;&#125;public class main &#123; public static void main(String[] args) throws ClassNotFoundException &#123; Exam exam = new Exam(99, &quot;zz&quot;); Object o = exam; Student student = new Student(&quot;xx&quot;, 20, o, Exam.class); JsonSerializer jsonSerializer = new JsonSerializer(); System.out.println(&quot;json序列化长度:&quot; + jsonSerializer.serialize(student).length); System.out.println(&quot;ProtoStuff序列化长度:&quot; + ProtoStuffUtil.serialize(student).length); &#125;&#125; &emsp;&emsp;然后我们测试两种序列化框架的序列化结果:&emsp;&emsp;从结果中可以发现，ProtoStuff序列化在长度上确实优于Json。但是这还不够，我们接下来要知道这个序列化的瓶颈在哪儿。很明显，与正常的序列化相比，我们在这里序列化最大的开销就是为了能够还原Object类型时所记录的Class信息。因此我们可以很自然的想到我们的调用方实现方都有同样的类信息，那么我们能不能用类名来替代Class对象呢？答案是可以的，我们先修改Student类，让Object对象变成一个字节数组，然后将Class对象变为字符串，在序列化和反序列化的双方通过字符串去查找类即可。 12345678910111213141516171819202122232425@Getter@Setter@AllArgsConstructor@NoArgsConstructor@Data@SerializationRegisterclass Student implements Serializable &#123; @Tag(1) private String name; @Tag(2) private int age; @Tag(3) private byte[] data; @Tag(4) private String clazz;&#125;public static void main(String[] args) throws ClassNotFoundException &#123; Exam exam = new Exam(99, &quot;zz&quot;); Object o = exam; Student student = new Student(&quot;xx&quot;, 20, ProtoStuffUtil.serialize(o), (exam.getClass().getName())); byte[] bytes = ProtoStuffUtil.serialize(student); System.out.println(bytes.length);&#125; &emsp;&emsp;运行后我们得到输出序列化长度为40，几乎只有序列化Class对象时的一半，如果我们将.getName()改为.getSimpleName()长度更是只有20。这就说明序列化对象时的开销主要都集中在了Class对象上。&emsp;&emsp;那么在此基础上，我们还有没有什么能够进一步缩短这个字符串的方法呢？有的兄弟，有的！我们可以创建一个动态字典对复杂的类名进行映射。这里Exam作为类名已经很短了，但我们仍然可以用单个字符如”#”来映射这个类。然后在序列化时将类名替换为对应的字符，这样反序列化时只需要反查字典即可。那么我们该怎么实现这个功能呢？要实现这个功能首先我们需要在调用方和实现方都是有一个相同的字典，根据上述我们对RPC三方的拆解，要实现这个功能我们我们肯定是在接口的提供方创建一个这样的字典。当然，一个简单的方法就是我们手动添加这样的映射，但是这样相当的不优雅而且工作量很大，因此我们不能这么做。我在这里想到的方法就是通过编译时注解来添加动态的创建字典。因此首先我实现了一个字典类: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class ClassMapper &#123; private static final char[] CHARS = new char[]&#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;@&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;%&#x27;, &#x27;^&#x27;, &#x27;&amp;&#x27;, &#x27;*&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;-&#x27;, &#x27;_&#x27;, &#x27;+&#x27;, &#x27;=&#x27;, &#x27;!&#x27;, &#x27;~&#x27;, &#x27;`&#x27;, &#x27;|&#x27;, &#x27;\\\\&#x27;, &#x27;/&#x27;, &#x27;:&#x27;, &#x27;;&#x27;, &#x27;&lt;&#x27;, &#x27;&gt;&#x27;, &#x27;?&#x27;, &#x27;[&#x27;, &#x27;]&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;, &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;&#125;; private static final AtomicInteger counter = new AtomicInteger(0); private static final ConcurrentHashMap&lt;String, String&gt; codeToClassName = new ConcurrentHashMap(); private static final ConcurrentHashMap&lt;String, String&gt; classNameToCode = new ConcurrentHashMap(); private static final Map&lt;String, Class&lt;?&gt;&gt; PRIMITIVE_TYPE_MAPPINGS = new HashMap(); public ClassMapper() &#123; &#125; public static void add(String className) &#123; if (classNameToCode.containsKey(className)) &#123; throw new IllegalArgumentException(&quot;Class name already exists: &quot; + className); &#125; else &#123; int count = counter.getAndIncrement(); String code = generateCode(count); codeToClassName.put(code, className); classNameToCode.put(className, code); &#125; &#125; public static String getClassNameByCode(String code) &#123; return (String)codeToClassName.get(code); &#125; public static String getCodeByClassName(String className) &#123; return (String)classNameToCode.get(className); &#125; private static String generateCode(int count) &#123; int length = 1; for(int max = CHARS.length; count &gt;= max; max *= CHARS.length) &#123; ++length; &#125; int[] digits = new int[length]; for(int i = length - 1; i &gt;= 0; --i) &#123; digits[i] = count % CHARS.length; count /= CHARS.length; &#125; StringBuilder sb = new StringBuilder(); int[] var5 = digits; int var6 = digits.length; for(int var7 = 0; var7 &lt; var6; ++var7) &#123; int d = var5[var7]; sb.append(CHARS[d]); &#125; return sb.toString(); &#125; static &#123; PRIMITIVE_TYPE_MAPPINGS.put(&quot;byte&quot;, Byte.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;short&quot;, Short.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;int&quot;, Integer.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;long&quot;, Long.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;float&quot;, Float.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;double&quot;, Double.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;char&quot;, Character.class); PRIMITIVE_TYPE_MAPPINGS.put(&quot;boolean&quot;, Boolean.class); Iterator var0 = PRIMITIVE_TYPE_MAPPINGS.entrySet().iterator(); while(var0.hasNext()) &#123; Map.Entry&lt;String, Class&lt;?&gt;&gt; entry = (Map.Entry)var0.next(); String primitiveName = (String)entry.getKey(); Class&lt;?&gt; wrapperClass = (Class)entry.getValue(); String wrapperName = wrapperClass.getName(); add(wrapperName); String code = (String)classNameToCode.get(wrapperName); classNameToCode.put(primitiveName, code); &#125; add(&quot;java.lang.String&quot;); try &#123; Class.forName(&quot;com.example.GeneratedRegistry&quot;); &#125; catch (ClassNotFoundException var6) &#123; System.out.println(&quot;No extra class to load&quot;); &#125; &#125;&#125; &emsp;&emsp;这个类主要的功能就是创建两个哈希表来建立一个编码和类名一一对应的字典，其映射规则也很简单，讲究一个先来后到，先来的优先用短的编码(要是在进一步优化可以考虑根据类型使用的频率使用哈夫曼树编码，不过我懒所以不想改了)，并且为了防止编码和类撞上，我们要求编码的第一个字符必须时数字或者特殊字符。然后在静态代码块中我们为java的基本类型创建一个映射，因为这些是常用且所有后续的RPC调用者都可以共享的。这里我们要注意到通过如int、double这样的非对象的类型我们无法通过他自己的类名来找到类，因此我们在这里将它们和它们对应的包裹类型共享一个编码。至于最后try catch中的类加载则是之后要用到的妙妙工具。&emsp;&emsp;有了用于类映射后的基本工具后我们就可以开始编写注解相关的内容了。注解本身很简单我在这里就不贴代码了，重点在于怎么处理这个注解。这里我使用了AbstractProcessor类在编译时生成一个静态代码块，类名为com.example.GeneratedRegistry，其中的内容就是把被目标注解修饰的实体类注册进ClassMapper中。处理代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@SupportedAnnotationTypes(&#123;&quot;org.example.SerializationRegister&quot;&#125;)@AutoService(&#123;Processor.class&#125;)public class SeriRegProcessor extends AbstractProcessor &#123; public SeriRegProcessor() &#123; &#125; public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(SerializationRegister.class); List&lt;String&gt; classNames = new ArrayList(); Iterator var5 = elements.iterator(); while(var5.hasNext()) &#123; Element element = (Element)var5.next(); if (element.getKind() == ElementKind.CLASS) &#123; TypeElement typeElement = (TypeElement)element; String className = typeElement.getQualifiedName().toString(); classNames.add(className); &#125; &#125; if (!classNames.isEmpty()) &#123; System.out.println(&quot;code generating&quot;); this.generateRegistryClass(classNames); &#125; return true; &#125; private void generateRegistryClass(List&lt;String&gt; classNames) &#123; try &#123; String packageName = &quot;com.example&quot;; String className = &quot;GeneratedRegistry&quot;; CodeBlock.Builder staticBlock = CodeBlock.builder(); Iterator var5 = classNames.iterator(); while(var5.hasNext()) &#123; String cn = (String)var5.next(); staticBlock.addStatement(&quot;$T.add($S)&quot;, new Object[]&#123;ClassMapper.class, cn&#125;); &#125; TypeSpec registryClass = TypeSpec.classBuilder(className).addModifiers(new Modifier[]&#123;Modifier.PUBLIC, Modifier.FINAL&#125;).addStaticBlock(staticBlock.build()).build(); JavaFile javaFile = JavaFile.builder(packageName, registryClass).build(); javaFile.writeTo(this.processingEnv.getFiler()); &#125; catch (IOException var7) &#123; var7.printStackTrace(); &#125; &#125; public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); System.out.println(&quot;----------&quot;); System.out.println(processingEnv.getOptions()); &#125; public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125;&#125; &emsp;&emsp;将我们想要的实体用注解修饰后，我们在编译后的target中能找到静态类com.example.GeneratedRegistry，其内容为： 123456public final class GeneratedRegistry &#123; static &#123; ClassMapper.add(&quot;com.example.commonapi.Student&quot;); ClassMapper.add(&quot;com.example.commonapi.Exam&quot;); &#125;&#125; &emsp;&emsp;到这里这个代码就完成了吗？否！还记得我们之前提到的妙妙工具吗？优于java对类的懒加载机制，如果GeneratedRegistry这个类没有被使用过，那么这段静态代码也完全不会执行，因此我在ClassMapper中手动加载了这个类来保证这段静态代码能够被执行。当时这个bug困扰了我非常久，只能说还是得学好java基础。&emsp;&emsp;最后就是一些适配器模式的工作了。在原本的序列化中我是没打算挖这么深的，因此用于传输的Request类和Response类都是用Object对象+Class对象来封装信息。但是现在我们用了这种全新的序列化方式，为了不重新写web端的代码，在这里我们就使用适配器模式来进行新老Request类和Response类之间的互相转换。这里我们以Request为例： 1234567891011121314@Data@Builder@AllArgsConstructor@NoArgsConstructorpublic class RPCRequest implements Serializable &#123; // 服务类名，客户端只知道接口名，在服务端中用接口名指向实现类 private String interfaceName; // 方法名 private String methodName; // 参数列表 private Object[] params; // 参数类型 private Class&lt;?&gt;[] paramsTypes;&#125; &emsp;&emsp;原本的Request类非常的简洁，为了满足适配器模式的要求，我们在这里不对其进行任何修改，而是创建一个新的ProtoStuffRPCRequest类。其params属性改为字节数组的数组，paramsTypes属性改为字符串数组。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758@Data@Builder@AllArgsConstructor@NoArgsConstructor@SerializationRegisterpublic class ProtoStuffRequest &#123; @Tag(1) private String interfaceName; @Tag(2) // 方法名 private String methodName; @Tag(3) // 参数列表 private byte[][] params; @Tag(4) // 参数类型 private String[] paramsTypes; public static ProtoStuffRequest getFromRPC(RPCRequest rpcRequest) &#123; ProtoStuffRequest protoStuffRequest = new ProtoStuffRequest(); protoStuffRequest.setInterfaceName(rpcRequest.getInterfaceName()); protoStuffRequest.setMethodName(rpcRequest.getMethodName()); Object[] objects = rpcRequest.getParams(); Class&lt;?&gt;[] clazz = rpcRequest.getParamsTypes(); byte[][] params = new byte[objects.length][]; String[]paramsTypes = new String[clazz.length]; for(int i = 0; i &lt; objects.length; i++) &#123; params[i] = ProtoStuffUtil.serialize(objects[i]); if (ClassMapper.getClassNameByCode(clazz[i].getName()) != null) &#123; paramsTypes[i] = ClassMapper.getClassNameByCode(clazz[i].getName()); &#125; else &#123; paramsTypes[i] = clazz[i].getName(); &#125; &#125; protoStuffRequest.setParams(params); protoStuffRequest.setParamsTypes(paramsTypes); return protoStuffRequest; &#125; public RPCRequest toRPCRequest() throws ClassNotFoundException &#123; RPCRequest request = new RPCRequest(); request.setInterfaceName(this.interfaceName); request.setMethodName(this.methodName); Object[] objects = new Object[this.params.length]; Class&lt;?&gt;[] clazz = new Class[this.params.length]; for (int i = 0; i &lt; this.params.length; i++) &#123; String className = this.paramsTypes[i]; if (ClassMapper.getClassNameByCode(className) != null) &#123; className = ClassMapper.getClassNameByCode(className); &#125; clazz[i] = Class.forName(className); objects[i] = ProtoStuffUtil.deserialize(this.params[i], clazz[i]); &#125; request.setParamsTypes(clazz); request.setParams(objects); return request; &#125;&#125; &emsp;&emsp;在ProtoStuffRequest类中，我们添加了一个静态方法getFromRPC，这个方法将原本的RPCRequest对象转换为ProtoStuffRequest对象。在toRPCRequest方法中，我们则将ProtoStuffRequest对象转换为原本的RPCRequest对象。这样我们只需要在序列化时调用一下转换Request的方法就可以在完全不改变原本Web端代码的基础上完成“狸猫换太子”。","categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://hit-1190200416.github.io/tags/rpc/"},{"name":"序列化","slug":"序列化","permalink":"http://hit-1190200416.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"rpc1","slug":"rpc1","date":"2025-05-21T05:56:20.000Z","updated":"2025-05-21T08:46:57.886Z","comments":true,"path":"2025/05/21/rpc1/","permalink":"http://hit-1190200416.github.io/2025/05/21/rpc1/","excerpt":"","text":"前言&emsp;&emsp;我的RPC项目来自于复现Gitee上的一个开源项目，不过在复现的时候根据自己对RPC的理解，增加了部分代码，比如服务注册和序列化的优化。这一系列的博客主要的目的就是记录一下自己增加这些代码的初心和实现是遇到的一些难题。 自动服务注册我对RPC的理解&emsp;&emsp;这里贴一段非常官方的说法：RPC（Remote Procedure Call，远程过程调用）是一种通过网络进行进程间通信的协议。RPC协议允许一个进程调用另一个进程的某个方法，就像调用本地方法一样。根据这段描述，我认为RPC的一个重要的目标就是调用远程方法就和调用一个本地库一样，毫无感知。 我认为的RPC的组成&emsp;&emsp;基于我粗略的学习Spring Cloud的认知，我觉得一个RPC的服务主要分为三个部分。一个是服务接口的提供方，这个部分的开发应该是最早的，其提供了RPC过程中需要调用的实体类以及函数接口，并且被打包成jar包安装到另外两个部分中。第二个部分是服务的实现方，这个部分实现提供方的接口，以供调用方通过web调用。最后就是调用方。调用方调用jar包中的接口，以此调用实现方中的最终实现。 服务注册&emsp;&emsp;第一个问题就是我们为什么需要服务注册。事实上RPC在调用的时候需要通过反射机制解析接口的内容，比如提供接口的接口类、方法名以及参数类型和返回值类型。然后使用合适的web框架将请求发送到服务实现方。服务实现方根据接口类、方法名以及参数类型和返回值类型找到对应的实现，然后调用实现，最后返回调用结果和函数的结果。这里存在一个问题，调用方只知道接口类、方法名以及参数类型和返回值类型，但是不知道对应的实现。因此服务的提供方就必须要将实现方注册到服务注册中心，服务调用方才能找到对应的实现方。在我学习的开源项目中，这个部分是由提供方手动注册实现的： 123456789101112131415161718192021222324public class ServiceProvider &#123; /** * 一个实现类可能实现多个接口 */ private Map&lt;String, Object&gt; interfaceProvider; public ServiceProvider()&#123; this.interfaceProvider = new HashMap&lt;&gt;(); &#125; public void provideServiceInterface(Object service)&#123; String serviceName = service.getClass().getName(); Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces(); for(Class clazz : interfaces)&#123; interfaceProvider.put(clazz.getName(),service); &#125; &#125; public Object getService(String interfaceName)&#123; return interfaceProvider.get(interfaceName); &#125;&#125; 12345678910111213141516public class TestServer &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); BlogService blogService = new BlogServiceImpl();// Map&lt;String, Object&gt; serviceProvide = new HashMap&lt;&gt;();// serviceProvide.put(&quot;com.ganghuan.myRPCVersion2.service.UserService&quot;,userService);// serviceProvide.put(&quot;com.ganghuan.myRPCVersion2.service.BlogService&quot;,blogService); ServiceProvider serviceProvider = new ServiceProvider(); serviceProvider.provideServiceInterface(userService); serviceProvider.provideServiceInterface(blogService); RPCServer RPCServer = new SimpleRPCRPCServer(serviceProvider); RPCServer.start(8899); &#125;&#125; &emsp;&emsp;这个实现方法看上去没什么问题，但是经过Spring框架熏陶过的我们肯定觉得这个方法不优雅。首先在服务启动的时候我们要手动的创建实现类，那么后续如果服务终止对资源的释放还得手动实现，这太过麻烦。因此将实现类注册为bean才是一个优雅的选择。通过注册bean然后在启动时找到bean手动放入serviceProvider中还是不够优雅，因此我们就需要利用到bean的生命周期，在服务创建完成时就将bean注册进serviceProvider中。因此我自定义了一个CustomService注解用于修饰我需要注册的实现类。 1234567@Target(ElementType.TYPE) // 只能用在类上@Retention(RetentionPolicy.RUNTIME) // 运行时可用@Service // 继承 @Service 的功能public @interface CustomService &#123; // 可添加额外的属性 String value() default &quot;&quot;;&#125; &emsp;&emsp;然后在bean的生命周期中解析这个注解，对所有包含了这个注解的bean进行注册进serviceProvider中。 1234567891011121314@Componentpublic class CustomServicePostProcessor implements BeanPostProcessor &#123; // 用于存放所有 @CustomService 修饰的 Bean @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; // 判断 Bean 是否被 @CustomService 修饰 if (bean.getClass().isAnnotationPresent(CustomService.class)) &#123; ServiceProvider.provideServiceInterface(bean); &#125; return bean; &#125;&#125; &emsp;&emsp;最后我们在Spring中配置这个生命周期的处理，这样我们就完成了自动服务注册。","categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://hit-1190200416.github.io/tags/rpc/"},{"name":"bean的生命周期","slug":"bean的生命周期","permalink":"http://hit-1190200416.github.io/tags/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]}],"categories":[],"tags":[{"name":"rpc","slug":"rpc","permalink":"http://hit-1190200416.github.io/tags/rpc/"},{"name":"序列化","slug":"序列化","permalink":"http://hit-1190200416.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"bean的生命周期","slug":"bean的生命周期","permalink":"http://hit-1190200416.github.io/tags/bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"}]}